#!/bin/zsh

# Author: Shaloo Shalini
# This script uses input files in common repo to 
# determine the list of supported chains and tokens
# for Arcana chain abstraction
# Input File 1: https://github.com/arcana-network/ca-common/blob/main/src/data/chainid.ts
# Input file 2: https://github.com/arcana-network/ca-common/blob/main/src/data/chaindata.ts

# Check if two input files are provided
if [ $# -ne 2 ]; then
    echo "Usage: $0 file1 file2"
    exit 1
fi

FILE1=$1
FILE2=$2
OUTPUT="output.md"

# Check if input files exist
if [ ! -f "$FILE1" ]; then
    echo "Error: File $FILE1 does not exist"
    exit 1
fi
if [ ! -f "$FILE2" ]; then
    echo "Error: File $FILE2 does not exist"
    exit 1
fi

# Check if FILE2 contains 'const RawData'
if ! grep -q 'const RawData' "$FILE2"; then
    echo "Error: $FILE2 does not contain 'const RawData'"
    exit 1
fi

# Step 1: Create currency mapping from file1
currency_map=$(awk '/export enum CurrencyID {/{flag=1; next} /}/{flag=0} flag' "$FILE1" | grep -v '^$' | awk -F'[=,] *' '{gsub(/^[ \t]+|[ \t]+$/, "", $1); gsub(/^[ \t]+|[ \t]+$/, "", $2); if ($2) print "\"" $2 "\": \"" $1 "\""}' | awk 'BEGIN {print "{"} NR>1 {print ","} {print} END {print "}"}')

if [ -z "$currency_map" ]; then
    echo "Error: Failed to parse currency mappings from $FILE1"
    exit 1
fi

# Debug: Print currency_map
#echo "DEBUG: currency_map:" > /dev/stderr
#echo "$currency_map" > /dev/stderr

# Step 2: Process file2 to get chain data
grep_output=$(cat "$FILE2" | grep -A 1000 'const RawData[ ]*=[ ]*\[')
if [ -z "$grep_output" ]; then
    echo "Error: Failed to find 'const RawData = [' in $FILE2"
    echo "$grep_output" | head -n 10
    exit 1
fi

chain_data=$(echo "$grep_output" | awk '
    BEGIN { in_array=0; in_chain=0; in_currencies=0; currency_list=""; chain_id_hex="" }
    /[ \t]*const RawData[ ]*=[ ]*\[/ { in_array=1; next }
    in_array && /[ \t]*\];/ { in_array=0; next }
    in_array && /[ \t]*ChainID32:/ {
        in_chain=1
        next
    }
    in_array && in_chain && !in_currencies && /[ \t]*"0x[0-9a-fA-F]+"/ {
        chain_id_hex=$1
        gsub(/"/, "", chain_id_hex)
        gsub(/,/, "", chain_id_hex)
        chain_id_short=substr(chain_id_hex, length(chain_id_hex)-7)
        printf "%d|", ("0x" chain_id_short)
        currency_list=""
        next
    }
    in_array && in_chain && /[ \t]*Currencies:[ ]*\[/ {
        in_currencies=1
        next
    }
    in_currencies && /[ \t]*CurrencyID:[ ]*[0-9]+[ ,]*/ {
        if (match($0, /CurrencyID:[ ]*([0-9]+)/)) {
            id=substr($0, RSTART+11, RLENGTH-11)
            if (currency_list == "") {
                currency_list=id
            } else {
                currency_list=currency_list " " id
            }
        }
        next
    }
    in_currencies && /[ \t]*\},/ {
        next
    }
    in_currencies && /[ \t]*\]/ {
        in_currencies=0
        in_chain=0
        if (currency_list != "") {
            # Remove extra spaces from currency_list
            gsub(/[ ]+/, " ", currency_list)
            gsub(/^ /, "", currency_list)
            gsub(/ $/, "", currency_list)
            print currency_list
        }
        next
    }
')

if [ -z "$chain_data" ]; then
    echo "Error: Failed to parse chain data from $FILE2"
    echo "$grep_output" | head -n 10
    exit 1
fi

# Debug: Print chain_data
#echo "DEBUG: chain_data:" > /dev/stderr
#echo "$chain_data" > /dev/stderr

# Declare an associative array
typeset -A currency_array

# Parse currency_map into key-value pairs with decimal keys
pairs=$(echo "$currency_map" | sed 's/[{},]//g' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/"\([^"]*\)":[[:space:]]*"\([^"]*\)"/\1:\2 /g' | tr -s ' ' '\n' | grep -v '^$' | awk -F':' '{ key=$1; if (key ~ /^0x[0-9A-Fa-f]+$/) { cmd="printf %d " key; cmd | getline dec; close(cmd); print dec ":" $2 } else { print $1 ":" $2 } }')

# Debug: Print the parsed pairs
#echo "Parsed pairs:"
#echo "$pairs"

# Populate the associative array
while IFS=':' read -r key value; do
    currency_array[$key]=$value
done <<< "$pairs"

# Print the entire array for verification
#echo -e "\nCurrency array contents:"
#for key in ${(k)currency_array}; do
    #echo "currency_array[$key]=${currency_array[$key]}"
#done

# Function to search for a value by key
search_currency() {
    local key="$1"
    if [[ -n "${currency_array[$key]}" ]]; then
        echo "${currency_array[$key]}"
    else
        echo "Not found"
    fi
}

# Create a markdown file
output_file="./includes/text-snippets/ca/ca_chains.md"
echo "<!---\n Do not edit this file \n It is auto generated.\n --->\n" > "$output_file"

# Process each chain
echo "$chain_data" | while IFS='|' read chain_id currencies; do
    # patch to handle Fuel with universe value 1, the lone chain
    # to be enhanced later when more universes add up
    if [[ "$chain_id" == "9889" ]]; then
        chain_name="Fuel"
    else
        # Get chain name using curl, targeting the <title> tag
        chain_name=$(curl -s --fail "https://chainlist.org/chain/$chain_id" | grep -o '<title>[^<]*</title>' | sed 's/<title>\([^|]*\) RPC and Chain settings.*/\1/' | head -n 1)
        if [ -z "$chain_name" ]; then
            chain_name="Unknown Chain"
        fi
    fi
    # Check if chain name contains "testnet"
    if [[ "$chain_name" =~ [Tt]estnet  || "$chain_name" =~ [Ss]epolia || "$chain_name" =~ [Az]moy ]]; then
        testnet="true"
    else
        testnet="false"
    fi

    # Append chain information to markdown file
    echo "## $chain_name" >> "$output_file"
    if [[ "$testnet" == "true" ]]; then
        echo "| Token | Folly |" >> "$output_file"
    else
        echo "| Token | Coral |" >> "$output_file"
    fi
    echo "|:--- |:---|" >> "$output_file"


    echo "---"
    echo "Chain id: $chain_id"
    echo "Chain name: name: $chain_name"
    #echo "currencies: $currencies"

    echo "$currencies" | tr -s ' ' '\n' | while read -r value; do
        if [[ -n "$value" ]]; then
            symbol=$(search_currency "$value")
            echo "| $symbol | âœ… |" >> "$output_file"
        fi
        echo $symbol
    done

    echo "\n" >> "$output_file"

done

exit 0